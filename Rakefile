require 'json'

desc "Generate OCUnit tests from html5lib tests"
task :gentests

FileList['Tests/html5lib/tokenizer/*.test'].each do |testpath|
  basename = File.basename(testpath, '.test')
  name = "Tokenizer#{basename[0].upcase}#{basename[1..-1]}Tests"
  json = JSON.parse(File.read(testpath))
  next if json['tests'].nil?
  objcpath = "Tests/Tokenizer/#{name}.m"
  file objcpath => [testpath, 'Rakefile'] do
    File.open(objcpath, 'w') do |objc|
      objc << <<-END
// This file was autogenerated from #{testpath}

#import <SenTestingKit/SenTestingKit.h>
#import "HTMLTokenizerTestUtilities.h"

@interface #{name} : SenTestCase

@end

@implementation #{name}
END
      json['tests'].each_with_index do |test, i|
        input = test['input']
        output = test['output']
        input = objc_literalize(input, doubleEscaped: test['doubleEscaped'])
        output = objc_literalize(output, doubleEscaped: test['doubleEscaped'])
        states = objc_literalize(test['initialStates'] || [''])
        if test['lastStartTag']
          lastStartTag = objc_literalize(test['lastStartTag'])
        end
        description = objc_literalize(test['description'])
        objc << <<-END
        
- (void)test#{i.to_s.rjust(json['tests'].size.to_s.length, '0')}
{
    NSArray *expectedTokens = ReifiedTokensForTestTokens(#{output});
    for (NSString *state in #{states}) {
        HTMLTokenizer *tokenizer = [[HTMLTokenizer alloc] initWithString:#{input} state:StateNamed(state)];
END
        if lastStartTag
          objc << <<-END
        [tokenizer setLastStartTag:#{lastStartTag}];
END
        end
        objc << <<-END
        STAssertEqualObjects(tokenizer.allObjects, expectedTokens, @"%@", #{description});
    }
}
END
      end
      objc << "\n@end\n"
    end
  end
  task :gentests => [objcpath]
end

def objc_literalize(json, options = {})
  case json
  when Hash
    objc_literalize_hash(json, options)
  when Array
    objc_literalize_array(json, options)
  when String
    objc_literalize_string(json, options)
  when Fixnum
    "@#{json}"
  when true
    "@YES"
  when false
    "@NO"
  when nil
    "[NSNull null]"
  else
    raise "Error converting to Objective-C literal: #{json.inspect}"
  end
end

def objc_literalize_hash(hash, options = {})
  parts = hash.map do |k, v|
    "#{objc_literalize_string(k, options)}: #{objc_literalize(v, options)}"
  end
  "@{#{parts.join(', ')}}"
end

def objc_literalize_array(array, options = {})
  "@[#{array.map{|i| objc_literalize(i, options)}.join(', ')}]"
end

def objc_literalize_string(string, options = {})
  slashes = (if options[:doubleEscaped] then '\\\\' else '\\' end) * 2
  unichars = []
  format = JSON.dump(string).gsub(/(?<!#{slashes})#{slashes}u(\h{4})/) do |hex|
    unichars << "(unichar)0x#{$1}"
    "%C"
  end
  if unichars.empty?
    "@#{format}"
  else
    "[NSString stringWithFormat:@#{format}, #{unichars.join(', ')}]"
  end
end

task :default => [:gentests]
