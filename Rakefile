require 'json'

namespace :gentests do
  desc "Translate html5lib tree construction tests to SenTestingKit"
  task :tree_construction
end

task :gentests => [:'gentests:tree_construction']

task :default => [:gentests]

# http://wiki.whatwg.org/wiki/Parser_tests#Tree_Construction_Tests
TREE_TEST_REGEX = /
  \#data\n
  (.*?)\n
  \#errors\n
  (.*?)
  (?: \#document-fragment\n
   (.+?)\n)?
  \#document\n
  ((?: \|[ ]+
    (?: [^"\n][^\n]* |
        ".*?")\n)+)
/xm

FileList['Tests/html5lib/tree-construction/*.dat'].each do |testpath|
  basename = File.basename(testpath, '.dat')
  name = basename.gsub(/[-_](.)/) do |m|
    c = $1
    c =~ /\d+/ ? c : c.upcase
  end.gsub(/tests(\d(?:[^\d]|$))/, 'tests0\1')
  name = "TreeGeneration#{name[0].upcase}#{name[1..-1]}Tests"
  objcpath = "Tests/Tree Construction/#{name}.m"
  file objcpath => [testpath, 'Rakefile'] do
    File.open(objcpath, 'w') do |objc|
      objc << <<-END
// This file was autogenerated from #{testpath}

#import <XCTest/XCTest.h>
#import "HTMLTreeConstructionTestUtilities.h"

@interface #{name} : XCTestCase

@end

@implementation #{name}

END
      i = 0
      File.read(testpath).scan(TREE_TEST_REGEX) do |data, errors, fragment, document|
        objc << <<-END
- (void)test#{(i).to_s.rjust(3, '0')}
{
END
        if fragment
          objc << <<-END
    HTMLElementNode *context = [[HTMLElementNode alloc] initWithTagName:#{objc_literalize(fragment)}];
    HTMLParser *parser = [[HTMLParser alloc] initWithString:#{objc_literalize(data)}
                                                    context:context];
END
        else
          objc << <<-END
    HTMLParser *parser = [[HTMLParser alloc] initWithString:#{objc_literalize(data)}];
END
    end
    objc << <<-END
    NSArray *fixture = ReifiedTreeForTestDocument(#{objc_literalize(document)});
    HTMLAssertParserState(parser, #{errors.split("\n").size}, fixture);
}

END
        i += 1
      end
      objc << "@end\n"
    end
  end
  task :'gentests:tree_construction' => [objcpath]
end

def objc_literalize(json, options = {})
  case json
  when Hash
    objc_literalize_hash(json, options)
  when Array
    objc_literalize_array(json, options)
  when String
    objc_literalize_string(json, options)
  when Fixnum
    "@#{json}"
  when true
    "@YES"
  when false
    "@NO"
  when nil
    "[NSNull null]"
  else
    raise "Error converting to Objective-C literal: #{json.inspect}"
  end
end

def objc_literalize_hash(hash, options = {})
  parts = hash.map do |k, v|
    "#{objc_literalize_string(k, options)}: #{objc_literalize(v, options)}"
  end
  "@{#{parts.join(', ')}}"
end

def objc_literalize_array(array, options = {})
  "@[#{array.map{|i| objc_literalize(i, options)}.join(', ')}]"
end

def objc_literalize_string(string, options = {})
  slashes = (if options[:doubleEscaped] then '\\\\' else '\\' end) * 2
  unichars = []
  format = JSON.dump(string).gsub(/(?<!#{slashes})#{slashes}u(\h{4})/) do |hex|
    unichars << "(unichar)0x#{$1}"
    "%C"
  end
  if unichars.empty?
    "@#{format}"
  else
    "[NSString stringWithFormat:@#{format}, #{unichars.join(', ')}]"
  end
end
